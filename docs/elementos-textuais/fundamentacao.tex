\chapter{Fundamentação}
\label{cap:fundamentacao}

% ---
\section{Arquitetura RISC-V}
% ---

O RISC-V é uma ISA (Instruction Set Architecture) baseada no conceito RISC (Reduced Instruction 
Set Computer). Diferente de arquiteturas proprietárias (como x86 e ARM), a RISC-V é aberta e 
livre de royalties, permitindo que universidades, empresas e desenvolvedores a utilizem e 
modifiquem. 

\begin{figure}[!htb]
	\caption{Arquitetura geral de um núcleo RISC-V, destacando o \textit{pipeline} de execução, o banco de registradores e as interfaces de memória.}
	\label{fig:risc-v-architecture}
	\centering
	\includegraphics[width=\textwidth]{risc-v-architecture.jpg} \\
	\begin{small}\textbf{Fonte: O Autor (2017)}\end{small}
\end{figure}

As principais características da arquitetura RISC-V incluem:
\begin{enumerate}
	\item Modularidade: núcleo mínimo (base ISA) e extensões opcionais.
	\item Simplicidade: instruções de tamanho fixo (geralmente 32 bits).
	\item Portabilidade: projetada para uso desde microcontroladores até supercomputadores.
	\item Ecossistema aberto: suporte crescente em compiladores, simuladores e hardware.
\end{enumerate}

Apesar do domínio da ARM no mercado de embarcados e móveis, a flexibilidade, o custo zero de 
licenciamento e a capacidade de customização do RISC-V o posicionam como um competidor 
formidável e uma alternativa estratégica para o futuro da computação.

Assim como processadores de arquitetura ARM (\textit{Advanced RISC Machine}), os RISC-V recebem 
esse nome por serem baseados nos princípios RISC - computação com conjunto de instruções 
reduzido (\textit{Reduced Instruction Set Computing}). 

Diferentemente da arquitetura CISC (\textit{Complex Instruction Set Computing}), que se baseia 
em um vasto conjunto de instruções complexas e especializadas, o RISC-V adota a filosofia do 
"menos é mais". Ao simplificar o conjunto de instruções, a arquitetura permite um hardware mais 
eficiente e previsível.

\subsection{Conjunto de Instruções RV32I}

O conjunto de instruções \textbf{RV32I} é a especificação base da arquitetura RISC-V para 
processadores de 32 bits. O nome indica que é um processador RISC-V de 32 bits de largura da 
palavra de processamento (\textit{word}) e utiliza a extensão de números inteiros 
(\textit{Integer}) - que é a base para todas as outras. A Tabela \ref{tab:rv32i_instr} lista as instruções base suportadas pelo núcleo RV32I.

\begin{xltabular}{\textwidth}{@{} l l X @{}}
\caption{Instruções do Conjunto RV32I} \label{tab:rv32i_instr} \\
\toprule
\textbf{Categoria} & \textbf{Mnemônico} & \textbf{Descrição} \\
\midrule
\endfirsthead
\toprule
\textbf{Categoria} & \textbf{Mnemônico} & \textbf{Descrição} \\
\midrule
\endhead
\bottomrule
\endfoot

% Aritmética e Lógica (R-Type)
\textbf{R-Type} & ADD & Soma aritmética entre registadores. \\
 & SUB & Subtração aritmética entre registadores. \\
 & SLL & Deslocamento lógico à esquerda (\textit{Shift Left Logical}). \\
 & SLT & Definir se menor que (\textit{Set Less Than}, com sinal). \\
 & SLTU & Definir se menor que (\textit{Set Less Than Unsigned}, sem sinal). \\
 & XOR & Ou exclusivo bit a bit. \\
 & SRL & Deslocamento lógico à direita (\textit{Shift Right Logical}). \\
 & SRA & Deslocamento aritmético à direita (\textit{Shift Right Arithmetic}). \\
 & OR & Ou lógico bit a bit. \\
 & AND & E lógico bit a bit. \\
\midrule

% Aritmética e Lógica Imediata (I-Type)
\textbf{I-Type} & ADDI & Soma com valor imediato. \\
 & SLTI & Definir se menor que imediato (com sinal). \\
 & SLTIU & Definir se menor que imediato (sem sinal). \\
 & XORI & Ou exclusivo imediato. \\
 & ORI & Ou lógico imediato. \\
 & ANDI & E lógico imediato. \\
 & SLLI & Deslocamento lógico à esquerda imediato. \\
 & SRLI & Deslocamento lógico à direita imediato. \\
 & SRAI & Deslocamento aritmético à direita imediato. \\
\midrule

% Upper Immediates (U-Type)
\textbf{U-Type} & LUI & Carregar Imediato Superior (\textit{Load Upper Immediate}). Preenche os 20 bits mais significativos. \\
 & AUIPC & Adicionar Imediato Superior ao PC (\textit{Add Upper Immediate to PC}). \\
\midrule

% Saltos (J-Type / I-Type)
\textbf{Jumps} & JAL & Salto e Link (\textit{Jump and Link}). Salto incondicional relativo ao PC. \\
 & JALR & Salto e Link Registrador (\textit{Jump and Link Register}). Salto incondicional via registrador. \\
\midrule

% Desvios Condicionais (B-Type)
\textbf{Branches} & BEQ & Desvio se Igual (\textit{Branch if Equal}). \\
 & BNE & Desvio se Diferente (\textit{Branch if Not Equal}). \\
 & BLT & Desvio se Menor (\textit{Branch if Less Than}, com sinal). \\
 & BGE & Desvio se Maior ou Igual (\textit{Branch if Greater/Equal}, com sinal). \\
 & BLTU & Desvio se Menor (\textit{Branch if Less Than}, sem sinal). \\
 & BGEU & Desvio se Maior ou Igual (\textit{Branch if Greater/Equal}, sem sinal). \\
\midrule

% Acesso à Memória (Loads)
\textbf{Loads} & LB & Carregar Byte (estende sinal). \\
 & LH & Carregar Meia-Palavra (\textit{half-word}, estende sinal). \\
 & LW & Carregar Palavra (\textit{word}, 32 bits). \\
 & LBU & Carregar Byte (sem sinal, preenche com zeros). \\
 & LHU & Carregar Meia-Palavra (sem sinal, preenche com zeros). \\
\midrule

% Acesso à Memória (Stores)
\textbf{Stores} & SB & Armazenar Byte. \\
 & SH & Armazenar Meia-Palavra. \\
 & SW & Armazenar Palavra. \\
\midrule

% Sistema e Sincronização
\textbf{System} & FENCE & Sincronização de memória e I/O. \\
 & ECALL & Chamada de sistema (\textit{Environment Call}). \\
 & EBREAK & Paragem para depuração (\textit{Environment Break}). \\

\end{xltabular}

É a ISA mais simples e fundamental, servindo como ponto de partida obrigatório. Sozinha, ela 
é suficiente para a criação de um processador de propósito geral e para a execução de um 
código compilado em C completo - usando a toolchain da RISC-V.

Um processador que se diz compatível com \textbf{RV32IMC}, por exemplo, implementa a base de 
inteiros (I), as operações de multiplicação/divisão (M) e instruções comprimidas de 16 bits (C).

\subsection{Extensões relevantes}

A arquitetura RISC-V distingue-se pela sua modularidade. O conjunto de instruções base (como o 
RV32I implementado neste trabalho) é a única parte obrigatória; sobre ela, projetistas podem 
acoplar módulos opcionais para otimizar o desempenho em domínios específicos.

As extensões padronizadas são identificadas por letras sufixas à nomenclatura do processador. 
As principais são:

\begin{itemize}

    \item \textbf{M (\textit{Integer Multiplication and Division})}: Adiciona hardware dedicado para 
	multiplicação e divisão de inteiros. Sem esta extensão, estas operações devem ser realizadas 
	via software (rotinas de emulação), o que é significativamente mais lento.
    
    \item \textbf{A (\textit{Atomic})}: Fornece instruções de leitura-modificação-escrita atômicas. 
	Estas são essenciais para a sincronização de memória e gerenciamento de exclusão mútua em 
	sistemas operacionais e arquiteturas \textit{multicore}.
    
    \item \textbf{F/D (\textit{Single/Double Precision Floating-Point})}: Adiciona um banco de 
	registradores separado e unidades de cálculo para operações com ponto flutuante, seguindo 
	o padrão IEEE 754 (32 bits para F e 64 bits para D).
    
    \item \textbf{C (\textit{Compressed})}: Introduz um conjunto de instruções de 16 bits que mapeiam 
	para as operações mais comuns de 32 bits. Isso aumenta a densidade de código, reduzindo o 
	tamanho dos binários e o uso de largura de banda de memória.
    
    \item \textbf{V (\textit{Vector})}: Habilita operações vetoriais (SIMD - \textit{Single Instruction, 
	Multiple Data}), permitindo o processamento paralelo de grandes volumes de dados, comum em 
	aplicações de IA e processamento de sinal.
    
    \item \textbf{B (\textit{Bit Manipulation})}: Oferece instruções eficientes para manipulação de 
	bits individuais (rotações, contagens, extrações), úteis em criptografia e drivers de 
	dispositivos.

\end{itemize}

É comum na literatura encontrar a designação \textbf{RV32G} ou \textbf{RV64G}, onde 'G' 
(\textit{General}) representa um agrupamento das extensões mais utilizadas em sistemas de 
propósito geral.

Além do padrão, a ISA reserva espaço de opcodes para \textbf{extensões customizadas (X)}. Esta 
característica permite a criação de aceleradores de hardware proprietários para tarefas 
especializadas (domain-specific architectures) sem quebrar a compatibilidade com o ecossistema 
de software base.

\section{VHDL e Projeto de Hardware}

A descrição de hardware deste projeto foi realizada utilizando a linguagem \textbf{VHDL} 
(\textit{VHSIC Hardware Description Language}). Diferente de linguagens de programação de 
software, que descrevem sequências de instruções, o VHDL é uma linguagem de descrição de 
hardware utilizada para modelar o comportamento concorrente e a estrutura de circuitos digitais.

Para este trabalho, adotou-se especificamente o padrão \textbf{VHDL-2008} (IEEE 1076-2008). 
Esta revisão da linguagem introduz construções modernas que aumentam a legibilidade e a 
capacidade de síntese do código, permitindo uma descrição mais concisa de lógicas complexas 
sem sacrificar o rigor tipológico característico da linguagem.

\section{Metodologias de Projeto}

A complexidade inerente ao desenvolvimento de um microprocessador exige uma metodologia de 
projeto rigorosa e estruturada. Este trabalho seguiu uma abordagem de desenvolvimento 
\textbf{Bottom-Up} (de baixo para cima) combinada com \textbf{Prototipagem Evolutiva}.

\subsection{Desenvolvimento Modular e Hierárquico}
O sistema foi decomposto em módulos fundamentais de menor complexidade. O desenvolvimento 
iniciou-se pelos componentes base do \textit{datapath} (Multiplexadores, ALU, Banco de 
Registradores), progredindo para a Unidade de Controle e, finalmente, para a integração no 
nível de topo (\textit{Top Level}). Cada módulo foi projetado como uma entidade independente, 
com interfaces (\textit{ports}) claramente definidas, facilitando o isolamento de falhas.

\subsection{Estratégia de Verificação e Simulação}
Dada a dificuldade de depurar erros diretamente no hardware físico, adotou-se a abordagem de 
testes através de simulações (\textit{textbenches}). Nenhum componente foi integrado ao sistema 
principal sem antes ser validado individualmente. 

O ambiente de simulação utilizado foi o \textbf{GHDL}, um simulador \textit{open-source} de alto  
desempenho, integrado a um fluxo de automação via \textbf{GNU Make}. Isso garante que todo o 
processo de compilação, simulação e visualização de ondas (via GTKWave) seja reprodutível e 
automatizado.